<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.78.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>Node中的OOM &#183; Wang3</title><meta name=description content><meta property="og:title" content="Node中的OOM"><link type=text/css rel=stylesheet href=https://yfsoftcom.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://yfsoftcom.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://yfsoftcom.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://yfsoftcom.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><meta name=google-site-verification content="TMkOXJMi2Hzjnf06eD_85orpkvedPBEb8iz3QoRAVWw"><meta name=baidu-site-verification content="hukmWhOg1i"><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?bb3408a776ca96ae2966f50b4f152271";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://yfsoftcom.github.io/><h1>Wang3</h1></a><p class=lead>A Blog For Wang3</p></div><nav><ul class=sidebar-nav><li><a href=https://yfsoftcom.github.io/>Home</a></li><li><a href=/categories/>Categories</a></li><li><a href=https://github.com/yfsoftcom/>Github</a></li><li><a href=/tags/>Tags</a></li><li><a href=/source/>推荐资源整理</a></li></ul></nav><p>&copy; 2023. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Node中的OOM</h1><time datetime=2023-03-06T09:25:00Z class=post-date>Mon, Mar 6, 2023</time><blockquote><p>Node.js 中的内存管理和垃圾回收是怎样的? 如何解决内存溢出的问题,以及如何找出导致OOM的根因?</p></blockquote><h3 id=内存溢出会怎样>内存溢出会怎样？</h3><p>于其它编程语言一样，Node内存溢出之后会抛出一个OOM的异常，并强行结束当前进程，导致服务不可用，通常的容器编排系统会重新启动一个新的实例，所以如果没有搜集日志并进行分析的话可能会忽略这类型的错误；通常日志会这样:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&lt;--- Last few GCs ---&gt;

<span style=color:#ae81ff>11629672</span> ms: Mark-sweep 1174.6 <span style=color:#f92672>(</span>1426.5<span style=color:#f92672>)</span> -&gt; 1172.4 <span style=color:#f92672>(</span>1418.3<span style=color:#f92672>)</span> MB, 659.9 / <span style=color:#ae81ff>0</span> ms <span style=color:#f92672>[</span>allocation failure<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>GC in old space requested<span style=color:#f92672>]</span>.
<span style=color:#ae81ff>11630371</span> ms: Mark-sweep 1172.4 <span style=color:#f92672>(</span>1418.3<span style=color:#f92672>)</span> -&gt; 1172.4 <span style=color:#f92672>(</span>1411.3<span style=color:#f92672>)</span> MB, 698.9 / <span style=color:#ae81ff>0</span> ms <span style=color:#f92672>[</span>allocation failure<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>GC in old space requested<span style=color:#f92672>]</span>.
<span style=color:#ae81ff>11631105</span> ms: Mark-sweep 1172.4 <span style=color:#f92672>(</span>1411.3<span style=color:#f92672>)</span> -&gt; 1172.4 <span style=color:#f92672>(</span>1389.3<span style=color:#f92672>)</span> MB, 733.5 / <span style=color:#ae81ff>0</span> ms <span style=color:#f92672>[</span>last resort gc<span style=color:#f92672>]</span>.
<span style=color:#ae81ff>11631778</span> ms: Mark-sweep 1172.4 <span style=color:#f92672>(</span>1389.3<span style=color:#f92672>)</span> -&gt; 1172.4 <span style=color:#f92672>(</span>1368.3<span style=color:#f92672>)</span> MB, 673.6 / <span style=color:#ae81ff>0</span> ms <span style=color:#f92672>[</span>last resort gc<span style=color:#f92672>]</span>.

&lt;--- JS stacktrace ---&gt;
FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory
 1: node::Abort<span style=color:#f92672>()</span> <span style=color:#f92672>[</span>/usr/bin/node<span style=color:#f92672>]</span>
</code></pre></div><p>这里有一些关键的信息： <code>Mark-sweep</code>, <code>GC in old space</code> , <code>1426.5MB</code></p><p>对于此类问题有一个粗暴的解决办法，就是增加 Old space 的 size:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ node --max-old-space-size<span style=color:#f92672>=</span><span style=color:#ae81ff>4096</span> yourFile.js
</code></pre></div><p>这样的话，old space 的size设置到了4G，大大调高了可分配的内存空间，也变相的解决了此类问题；不过代码中的潜在问题还是没有被找出来。</p><h3 id=node中的内存管理是什么样的>Node中的内存管理是什么样的？</h3><p>Node与不同于 C，C++，Rust此类需要手动管理内存的编程语言，它带有一个强大的GC，会在合适的时机进行无用对象的销毁和回收，一个 Node 程序是如何分配和管理内存的？</p><p>大致上，内存被区分为堆和栈，其中栈内存用于存放指针，基础类型的数据，函数调用等，通常这里空间很小，访问频次很高，堆内存主要用于存放对象的具体内容。</p><p>Node 借助了 Chrome 的V8引擎，在V8中，堆内存还被分为 <code>new space</code> 和 <code>old space</code> ，简单来说：刚被分配出来的内存变量都是new generate，被放入到 new space 中使用，随着时间的推移，进过2轮的垃圾回收都没有被销毁的对象会被放入到 old space 中，从而为这个 new space 腾出空间来存放新的对象，默认的 new space 空间是 16KB，可以通过参数进行调整，不过不建议调的非常大，因为过大的空间会导致 GC 的负担过重，服务会出现间歇性的停滞，典型的 STW（stop the world）问题。</p><h3 id=如何进行gc>如何进行GC？</h3><p>V8 位了能优化这个问题，对 new space 和 old space 都分配了不同的GC算法：</p><ul><li><p>Scavenge for New Space</p><p>New Space空间被分配完了之后，如果有新的内存分配需求，会触发一次GC，删除未引用的对象，如果对象经过了2轮的GC依然存活，则转入到 old space，这样的过程会导致 STW 不过时间非常短（1～10ms）这个是在 new space 的默认大小情况下。</p></li><li><p>Mark-sweep for Old Space</p><p>标记删除法是大多的编程语言的gc算法，也是实现方式比较简单的一种，简单来说就是每次GC从根节点开始，向外搜索，有引用就标记成 Black，无引用的标记成 White，全部遍历一遍之后，会在之后扫描全部的 white 对象，然后进行删除。</p></li></ul><p>通过添加一个命令行参数 <code>--trace-gc</code>，可以track到每一次GC事件的具体信息:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ node --trace-gc --max-old-space-size<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span> script.js
</code></pre></div><h3 id=如何调试oom并定位内存问题>如何调试OOM，并定位内存问题？</h3><p>通过对内存管理和GC的背后逻辑梳理，接下来可以通过一些方法来定位内存问题：</p><ul><li>运行时添加命令行参数，改小old space的空间大小来尝试复现问题</li><li>通过引入 v8 和 <a href=https://nodejs.org/api/perf_hooks.html>performance hooks</a> 模块输出 GC 过程中的详细信息</li><li>也可以通过一些工具如 mdb 将详细的堆栈内容进行输出以定位具体的行代码问题</li></ul><p>扩展阅读：</p><ul><li><a href=https://nodejs.org/en/docs/guides/diagnostics/memory/using-gc-traces/>https://nodejs.org/en/docs/guides/diagnostics/memory/using-gc-traces/</a></li></ul></div><h2>Comments</h2><script src=https://giscus.app/client.js data-repo=yfsoftcom/yfsoftcom.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk2NDUzNDEzMw==" data-category=General data-category-id=DIC_kwDOA9i2dc4CQcP9 data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></main><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-153851706-1','auto');ga('send','pageview');}</script></body></html>