<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.78.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>Node中的Stream &#183; Wang3</title><meta name=description content><link type=text/css rel=stylesheet href=https://blog.yunplus.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://blog.yunplus.io/css/poole.css><link type=text/css rel=stylesheet href=https://blog.yunplus.io/css/syntax.css><link type=text/css rel=stylesheet href=https://blog.yunplus.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><meta name=google-site-verification content="TMkOXJMi2Hzjnf06eD_85orpkvedPBEb8iz3QoRAVWw"><meta name=baidu-site-verification content="hukmWhOg1i"><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?bb3408a776ca96ae2966f50b4f152271";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://blog.yunplus.io/><h1>Wang3</h1></a><p class=lead>A Blog For Wang3</p></div><nav><ul class=sidebar-nav><li><a href=https://blog.yunplus.io/>Home</a></li><li><a href=/categories/>Categories</a></li><li><a href=https://github.com/yfsoftcom/>Github</a></li><li><a href=/tags/>Tags</a></li><li><a href=/source/>推荐资源整理</a></li></ul></nav><p>&copy; 2022. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Node中的Stream</h1><time datetime=2022-03-03T09:25:00Z class=post-date>Thu, Mar 3, 2022</time><blockquote><p>Node.js 中的 Stream 模块是非常厉害，高效却不容易理解的模块。</p></blockquote><p>常常因为不太理解而不太敢用。</p><p>Node 以非阻塞式 IO 的概念进入编程市场，IO 包含文件读写，网络传输等。非阻塞式 IO 如何高效，这个牵扯到底层的事件轮询，epoll 模型等。</p><p>stream模块的设计秉承了 NIO 的思想，通过数据的流动来驱动系统资源的调配。</p><p>引用的文章提供了一个非常好的案例，对于一个 400 MB 左右的文件，通过非 stream 的方式传输，系统的内存占用会增加到 400+ MB，也就是说，程序会将文件全部加载内存，再通过建立好的链接进行数据传输。这点也非常符合直觉，很好理解。</p><p>但是 Node.js 的 stream 是那么巧妙而高效，可以以非常小的内存消耗满足同样的性能表现；进过测试的内存表现并没有明显增加，只是增加到 40+ MB 左右，也就是按需获取，只加载即将需要的数据，清理已经消费过的数据；也有点类似于缓冲区。</p><p>stream 不仅可以用于以上场景，还可以非常方便的将不同的输入输出进行链接，类似于 Linux 的管道，输入输出建立管道就可以单向的流入，流出数据，同样也会高效的利用内存资源。</p><p>为了更好的利用好这种模型，Node 抽象出了 Readable & Writeable 接口，通过实现对应的接口函数，即可创建对应的 stream 对象，进行大量数据的传输。</p><p>不过有些场景下需要特殊的接口，比如 Duplex 接口，既可以作为输入也可以作为输出，比如 TCP 链接，可读可写。</p><p>这些接口都是利用了 EventEmit 这个模块，通过订阅系统事件来进行逻辑控制。</p><p>很多跟 IO 相关的开源 package 都是运用了这个模块，比如：db, redis 相关的模块都是这样的。</p><h3 id=给本文带来启发的文章>给本文带来启发的文章</h3><p><a href=https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/>https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/</a></p><p><a href=https://nodesource.com/blog/understanding-streams-in-nodejs/>https://nodesource.com/blog/understanding-streams-in-nodejs/</a></p></div></main><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-153851706-1','auto');ga('send','pageview');}</script></body></html>