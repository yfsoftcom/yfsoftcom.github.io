<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OOM on Wang3</title><link>https://yfsoftcom.github.io/tags/oom/</link><description>Recent content in OOM on Wang3</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 06 Mar 2023 09:25:00 +0000</lastBuildDate><atom:link href="https://yfsoftcom.github.io/tags/oom/index.xml" rel="self" type="application/rss+xml"/><item><title>Node中的OOM</title><link>https://yfsoftcom.github.io/posts/node%E4%B8%AD%E7%9A%84oom/</link><pubDate>Mon, 06 Mar 2023 09:25:00 +0000</pubDate><guid>https://yfsoftcom.github.io/posts/node%E4%B8%AD%E7%9A%84oom/</guid><description>Node.js 中的内存管理和垃圾回收是怎样的? 如何解决内存溢出的问题,以及如何找出导致OOM的根因?
内存溢出会怎样？ 于其它编程语言一样，Node内存溢出之后会抛出一个OOM的异常，并强行结束当前进程，导致服务不可用，通常的容器编排系统会重新启动一个新的实例，所以如果没有搜集日志并进行分析的话可能会忽略这类型的错误；通常日志会这样
&amp;lt;--- Last few GCs ---&amp;gt; 11629672 ms: Mark-sweep 1174.6 (1426.5) -&amp;gt; 1172.4 (1418.3) MB, 659.9 / 0 ms [allocation failure] [GC in old space requested]. 11630371 ms: Mark-sweep 1172.4 (1418.3) -&amp;gt; 1172.4 (1411.3) MB, 698.9 / 0 ms [allocation failure] [GC in old space requested]. 11631105 ms: Mark-sweep 1172.4 (1411.3) -&amp;gt; 1172.4 (1389.3) MB, 733.5 / 0 ms [last resort gc]. 11631778 ms: Mark-sweep 1172.</description></item></channel></rss>